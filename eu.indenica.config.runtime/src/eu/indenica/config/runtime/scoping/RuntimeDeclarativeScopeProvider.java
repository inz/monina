/*
 * generated by Xtext
 */
package eu.indenica.config.runtime.scoping;

import java.util.Collection;
import java.util.List;

import org.apache.log4j.Logger;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.Path;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.IFileEditorInput;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.IScopeProvider;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;

import com.google.common.collect.Lists;
import com.google.inject.Inject;
import com.google.inject.name.Named;

import de.uni_hildesheim.sse.integration.common.IModelInfo;
import de.uni_hildesheim.sse.integration.common.ModelException;
import de.uni_hildesheim.sse.integration.tuv.IModel;
import de.uni_hildesheim.sse.integration.tuv.IModelAccess;
import de.uni_hildesheim.sse.ivml.IvmlFactory;
import de.uni_hildesheim.sse.ivml.VariableDeclarationPart;
import eu.indenica.config.runtime.runtime.AttributeEmissionDeclaration;
import eu.indenica.config.runtime.runtime.Event;
import eu.indenica.config.runtime.runtime.EventEmissionDeclaration;
import eu.indenica.config.runtime.runtime.EventSource;
import eu.indenica.config.runtime.runtime.EventSourceDeclaration;
import eu.indenica.config.runtime.runtime.Fact;
import eu.indenica.config.runtime.runtime.IndenicaMonitoringQuery;
import eu.indenica.config.runtime.runtime.RuntimeModel;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#scoping on how and when
 * to use it
 * 
 */
public class RuntimeDeclarativeScopeProvider extends
        AbstractDeclarativeScopeProvider {

    private final static Logger logger = Logger
            .getLogger(RuntimeDeclarativeScopeProvider.class);

    public final static String NAMED_DELEGATE =
            "eu.indenica.config.runtime.scoping.RuntimeDeclarativeScopeProvicer.delegate";

    @Inject(optional = true)
    @Named(NAMED_DELEGATE)
    private IScopeProvider delegate;

    /*
     * (non-Javadoc)
     * 
     * @see org.eclipse.xtext.xbase.scoping.XtypeScopeProvider#getDelegate()
     */
    @Override
    public IScopeProvider getDelegate() {
        return delegate;
    }

    /*
     * (non-Javadoc)
     * 
     * @see
     * org.eclipse.xtext.xbase.scoping.XtypeScopeProvider#setDelegate(org.eclipse
     * .xtext.scoping.IScopeProvider)
     */
    @Override
    public void setDelegate(IScopeProvider delegate) {
        this.delegate = delegate;
    }

    protected IScope delegateGetScope(EObject context, EReference reference) {
        if(delegate != null)
            return super.delegateGetScope(context, reference);
        return IScope.NULLSCOPE;
    }

    // IScope scope_EventAttribute(EventEmissionDeclaration ctx, EReference ref)
    // {
    // logger.info("event attributes: " +
    // ctx.getEvent().getAttributes().toString());
    // return Scopes.scopeFor(ctx.getEvent().getAttributes());
    // }

    /**
     * Looks up valid event attributes for rename statements in event attribute
     * emit statement.
     * 
     * @param ctx
     *            the attribute emit statement
     * @param ref
     *            the reference to the event attribute
     * @return a scope containing all valid event attributes
     */
    IScope scope_AttributeEmissionDeclaration_attribute(
            final AttributeEmissionDeclaration ctx, final EReference ref) {
        logger.debug("Getting scope for AttributeEmissionDeclaration, "
                + "EventEmissionDecl: " + ctx.eContainer());
        return Scopes.scopeFor(((EventEmissionDeclaration) ctx.eContainer())
                .getEvent().getAttributes());
    }

    /**
     * Looks up generally available event attributes within a monitoring rule
     * 
     * @param ctx
     *            the monitoring rule
     * @param ref
     * @return a scope containing all valid event attributes
     */
    IScope scope_EventAttribute(final IndenicaMonitoringQuery ctx,
            final EReference ref) {
        logger.debug("Getting scope for EventAttribute in query " + ctx);
        Collection<EObject> elements = Lists.newArrayList();
        Collection<EventSource> sources = Lists.newArrayList();

        for(EventSourceDeclaration source : ctx.getSources())
            sources.addAll(source.getSources());

        for(EventSource source : sources) {
            for(Event event : source.getEvents()) {
                // elements.add(event);
                elements.addAll(event.getAttributes());
            }
        }
        // if(logger.isInfoEnabled()) {
        // logger.info("Scope: ");
        // for(EObject o : elements)
        // logger.info("  " + o.toString());
        // }
        return Scopes.scopeFor(elements);
    }

    /**
     * Looks up event attributes available for partitioning in Fact rules
     * 
     */
    IScope scope_EventAttribute(final Fact ctx, final EReference ref) {
        logger.debug("Getting scope vor EventAttribute in fact " + ctx);
        Collection<EObject> elements = Lists.newArrayList();
        Collection<EventSource> sources = Lists.newArrayList();

        sources.addAll(ctx.getSource().getSources());

        for(EventSource source : sources) {
            for(Event event : source.getEvents()) {
                elements.addAll(event.getAttributes());
            }
        }
        // if(logger.isInfoEnabled()) {
        // logger.info("Scope: ");
        // for(EObject o : elements)
        // logger.info("  " + o.toString());
        // }
        return Scopes.scopeFor(elements);
    }

    /**
     * Looks up qualified names for IVML references
     * 
     * @throws ModelException
     *             if parsing IVML failed.
     */
    IScope scope_VariableDeclarationPart(final RuntimeModel ctx,
            final EReference ref) throws ModelException {
        try {
            Collection<EObject> result = Lists.newArrayList();

            Resource stubsResource = createStubsResource(ctx);

            logger.debug("Getting scope for variable declaration in " + ctx);
            IModelAccess modelAccess = IModelAccess.getInstance();
            IProject project =
                    ResourcesPlugin
                            .getWorkspace()
                            .getRoot()
                            .getFile(
                                    new Path(ctx.eResource().getURI()
                                            .toPlatformString(true)))
                            .getProject();
            List<IModelInfo> availableModels =
                    modelAccess.getAvailableModels(project);

            logger.info("Projects found: " + availableModels.size());
            for(IModelInfo modelInfo : availableModels) {
                IModel model = modelAccess.obtainModel(modelInfo);
                logger.info("Found: " + model.getVariablesCount()
                        + " variables.");

                for(int i = 0; i < model.getVariablesCount(); i++) {
                    VariableDeclarationPart element =
                            IvmlFactory.eINSTANCE
                                    .createVariableDeclarationPart();
                    element.setName(model.getName() + "::"
                            + model.getVariable(i).getName());
                    stubsResource.getContents().add(element);
                    result.add(element);
                }
            }
            return Scopes.scopeFor(result);
        } catch(ModelException e) {
            logger.error("Failed to get models!", e);
        } catch(Exception e) {
            logger.error("Something went wrong!", e);
        }
        return null;
    }

    /**
     * Create/use a stub resource to hold the IVML variables found in the model.
     * 
     * @param ctx
     *            the {@link RuntimeModel} to create the stubs resource in
     * @return the stubs {@link Resource}
     */
    private Resource createStubsResource(final RuntimeModel ctx) {
        URI stubsUri = URI.createURI("file:/tmp/dummy-stubs.xmi");
        Resource stubsResource =
                ctx.eResource().getResourceSet().getResource(stubsUri, false);
        if(stubsResource == null) {
            stubsResource =
                    ctx.eResource().getResourceSet().createResource(stubsUri);
        }
        return stubsResource;
    }
}
