//grammar eu.indenica.config.runtime.Runtime with org.eclipse.xtext.common.Terminals
grammar eu.indenica.config.runtime.Runtime with org.eclipse.xtext.xbase.Xbase


generate runtime "http://www.indenica.eu/config/runtime/Runtime"
 
RuntimeModel:
 (elements+=AbstractElement)*
;
 
AbstractElement:
  Import | Event | Action | System | MonitoringQuery | FactRule // | AdaptationRule
;

Import:
	'import' importedNamespace=QualifiedNameWithWildcard
;

System:
	'component' name=QualifiedName '{'
		metadata=SystemMetadata &
		(elements+=SystemElement)* &
		host=HostRef
	'}'
;

SystemElement:
  EventRef | ActionRef
;

SystemMetadata:
	{SystemMetadata} (('vendor' vendor=STRING)? &
	('version' version=STRING)?)
;

Event:
	'event' name=ID '{'
		(attributes+=EventAttribute)*
	'}'
;

EventRef:
	'event' name=[Event | QualifiedName] 
	frequency=EmissionFrequency?
;

EmissionFrequency:
	'every' (interval=DECIMAL unit=TimeUnit) | (frequency=DECIMAL 'Hz')
;

Action:
	'action' name=ID '{'
		(parameters+=EventAttribute)*
	'}'
;

ActionRef:
	'action' name=[Action | QualifiedName]
;

EventAttribute:
	name=ID ':' type=QualifiedName
;

Host:
	'host' name=ID '{'
		address=HostAddress & capacity=HostCapacity & 
		endpointAddress=EndpointAddress
	'}'
;

HostRef:
	'host' name=[Host | QualifiedName]
;

HostAddress:
	fqdn=Fqdn | ipv4=IPV4_ADDRESS | ipv6=IPV6_ADDRESS
;

Fqdn:
	QualifiedName
;

terminal IPV4_ADDRESS:
	INT '.' INT '.' INT '.' INT
;

/*
 * IPv6 Address specification from http://www.ietf.org/rfc/rfc2373.txt,
 * Appendix B: 
 *
	  IPv6address=hexpart [ ":" IPv4address ]
	  IPv4address=1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT
	
	  IPv6prefix =hexpart "/" 1*2DIGIT
	
	  hexpart=hexseq | hexseq "::" [ hexseq ] | "::" [ hexseq ]
	  hexseq =hex4 *( ":" hex4)
	  hex4   =1*4HEXDIG
 */
terminal IPV6_ADDRESS:
	HEXPART (':' IPV4_ADDRESS)?
;

terminal fragment HEXPART:
	HEXSEQ | HEXSEQ '::' HEXSEQ? | '::' HEXSEQ?
;

terminal fragment HEXSEQ:
	HEX4 (':' HEX4)*
;

terminal fragment HEX4:
	HEXDIGIT (HEXDIGIT (HEXDIGIT (HEXDIGIT)?)?)?
;

terminal fragment HEXDIGIT:
	'0' .. '9' |
	'A' .. 'F' |
	'a' .. 'f'
;

HostCapacity:
	'capacity' capacity=INT
;

EndpointAddress:
	'endpoint' endpointAddress=STRING
;
 
MonitoringQuery:
  'query' name=ID '{'
	(
		sources+=EventSourceDeclaration |
		emits+=EventEmissionDeclaration
	)*
  	window=WindowDeclaration?
	condition=MonitoringConditionDeclaration? 
  '}'
;

EventEmissionDeclaration:
	'emit' event=[Event | QualifiedName] '('
		attributes+=AttributeEmissionDeclaration 
		(',' attributes+=AttributeEmissionDeclaration)*
	')'
;

AttributeEmissionDeclaration:
	expr=ConditionalExpression ('as' attribute=[EventAttribute | QualifiedName])?
;

EventSourceDeclaration:
	'from' sources+=EventSource (',' sources+=EventSource)* 
;

EventSource:
	('source' | 'sources') systems+=[EventSourceType | QualifiedName] 
		(',' systems+=[EventSourceType | QualifiedName])*
	('event' | 'events') events+=[Event | QualifiedName] 
		(',' events+=[Event | QualifiedName])*
	('as' sourceName=ID)? 
;

EventSourceType:
	System | MonitoringQuery
;

// FIXME: make proper window declaration!
WindowDeclaration:
	'window' expression=WindowExpression
;

WindowExpression:
	BatchWindow | TimeWindow
;

BatchWindow:
	value=INT ('event' | 'events')?
;

TimeWindow:
	value=INT unit=TimeUnit
;

enum TimeUnit:
	SECONDS='s' | SECONDS='sec' | SECONDS='second' | SECONDS='seconds' |
	MINUTES='m' | MINUTES='min' | MINUTES='minute' | MINUTES='minutes' |
	HOURS='h' | HOURS='hour' | HOURS='hours' |
	DAYS='d' | DAYS='day' | DAYS='days' |
	MONTHS='M' | MONTHS='month' | MONTHS='months' |
	YEARS='y' | YEARS='year' | YEARS='years'
;

MonitoringConditionDeclaration:
	'where' expression=ConditionalExpression
;

FactRule:
	{FactRule} 'fact' name=ID? '{'
		source=EventSourceDeclaration
		partitionKey=PartitionKey
	'}'
;

PartitionKey:
	'by' key=[EventAttribute | QualifiedName]
;


AttributeAssignment:
	'set' name=ID value=ConditionalExpression
;

/* Expression syntax adapted from 
 * http://openjdk.java.net/projects/compiler-grammar/antlrworks/Java.g
 * and the Xbase XExpression 	
 */
ConditionalExpression:
	ConditionalOrExpression
;

ConditionalOrExpression returns ConditionalExpression:
	ConditionalAndExpression (=>({BinaryExpression.leftOperand=current} 
		operator=OrOperator) rightOperand=ConditionalAndExpression
	)*
;

OrOperator:
	{OrOperator} operator=('||' | 'or' | 'OR')
;

ConditionalAndExpression returns ConditionalExpression:
	EqualityExpression (=>({BinaryExpression.leftOperand=current} 
		operator=AndOperator) rightOperand=EqualityExpression)*
;

AndOperator:
	{AndOperator} operator=('&&' | 'and' | 'AND')
;

EqualityExpression returns ConditionalExpression:
	RelationalExpression (=>({BinaryExpression.leftOperand=current}
		operator=EqualityOperator) rightOperand=RelationalExpression
	)*
;

EqualityOperator:
	{EqualityOperator} operator=('=' | '!=')
;

RelationalExpression returns ConditionalExpression:
	AdditiveExpression (=>({BinaryExpression.leftOperand=current}
		operator=CompareOperator) rightOperand=AdditiveExpression
	)*
;

CompareOperator:
	{CompareOperator} operator=('<' | '<=' | '>=' | '>')
;

AdditiveExpression returns ConditionalExpression:
	MultiplicativeExpression (=>({BinaryExpression.leftOperand=current}
		operator=AdditiveOperator) 
		rightOperand=MultiplicativeExpression
	)*
;

AdditiveOperator:
	{AdditiveOperator} operator=('+' | '-')
;

MultiplicativeExpression returns ConditionalExpression:
	UnaryExpression (=>({BinaryExpression.leftOperand=current}
		operator=MultiplicativeOperator)
		rightOperand=UnaryExpression
	)*
;

MultiplicativeOperator:
	{MultiplicativeOperator} operator=('*' | '/' | '%')
;

UnaryExpression returns ConditionalExpression:
	{UnaryExpression} operator=UnaryOperator 
		operand=PrimaryExpression 
	| PrimaryExpression
;

UnaryOperator returns Operator:
	{UnaryOperator} operator=('-' | 'not' | '!')
;

Operator returns Operator:
	AndOperator | OrOperator | CompareOperator | AdditiveOperator |
	MultiplicativeOperator
;

PrimaryExpression returns ConditionalExpression:
	ParenthesizedExpression |
	Literal |
	FeatureCall
;

ParenthesizedExpression returns ConditionalExpression:
	'(' ConditionalExpression ')'
;

FeatureCall:
	{FeatureCall} attribute=[EventAttribute | QualifiedName]
;

Literal returns ConditionalExpression:
	BooleanLiteral |
	NumberLiteral |
	NullLiteral |
	StringLiteral 
;

BooleanLiteral returns ConditionalExpression:
	{BooleanLiteral} ('false' | isTrue?='true')
;

NumberLiteral returns ConditionalExpression:
	{NumberLiteral} value=Number	
;


NullLiteral returns ConditionalExpression:
	{NullLiteral} 'null'
;


StringLiteral returns ConditionalExpression:
	{StringLiteral} value=STRING
;

//QualifiedName:
//	ID ('.' ID)*
//;

QualifiedNameWithWildcard:
	QualifiedName '.*'?	
;

