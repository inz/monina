//grammar eu.indenica.config.runtime.Runtime with org.eclipse.xtext.common.Terminals
grammar eu.indenica.config.runtime.Runtime with org.eclipse.xtext.xbase.Xbase


generate runtime "http://www.indenica.eu/config/runtime/Runtime"
 
RuntimeModel:
 (elements += AbstractElement)*
;
 
AbstractElement:
  Import | Event | Action | System | MonitoringRule | FactRule // | AdaptationRule
;

Import:
	'import' importedNamespace = QualifiedNameWithWildcard
;

System:
	'system' name = QualifiedName '{'
		metadata = SystemMetadata
		(elements += SystemElement)*
	'}'
;

SystemElement:
  EventRef | ActionRef
;

SystemMetadata:
	{SystemMetadata} (('vendor' vendor = STRING)? &
	('version' version = STRING)?)
;

Event:
	'event' name = ID '{'
		(attributes += EventAttribute)*
	'}'
;

EventRef:
	'event' name = [Event | QualifiedName]
;

Action:
	'action' name = ID '{'
		(parameters += EventAttribute)*
	'}'
;

ActionRef:
	'action' name = [Action | QualifiedName]
;

EventAttribute:
	name = ID ':' type = QualifiedName
;
 
MonitoringRule:
  'monitoringrule' name = ID '{'
	(
		sources += EventSourceDeclaration |
		emits += EventEmissionDeclaration
	)*
  	window = WindowDeclaration?
	condition = MonitoringConditionDeclaration? 
  '}'
;

EventEmissionDeclaration:
	'emit' event = [Event | QualifiedName] '('
		attributes += AttributeEmissionDeclaration 
		(',' attributes += AttributeEmissionDeclaration)*
	')'
;

AttributeEmissionDeclaration:
	expr = ID ('as' attribute = [EventAttribute | QualifiedName])?
;

EventSourceDeclaration:
	'from' sources += EventSource (',' sources += EventSource)* 
;

EventSource:
	('source' | 'sources') systems += [EventSourceType | QualifiedName] 
		(',' systems += [EventSourceType | QualifiedName])*
	('event' | 'events') events += [Event | QualifiedName] 
		(',' events += [Event | QualifiedName])*
	('as' sourceName = ID)? 
;

EventSourceType:
	System | MonitoringRule
;

// FIXME: make proper window declaration!
WindowDeclaration:
	'window' expression = WindowExpression
;

WindowExpression:
	BatchWindow | TimeWindow
;

BatchWindow:
	value=INT ('event' | 'events')?
;

TimeWindow:
	value=INT unit=TimeUnit
;

enum TimeUnit:
	SECONDS = 's' | SECONDS = 'sec' | SECONDS = 'second' | SECONDS = 'seconds' |
	MINUTES = 'm' | MINUTES = 'min' | MINUTES = 'minute' | MINUTES = 'minutes' |
	HOURS = 'h' | HOURS = 'hour' | HOURS = 'hours' |
	DAYS = 'd' | DAYS = 'day' | DAYS = 'days' |
	MONTHS = 'M' | MONTHS = 'month' | MONTHS = 'months' |
	YEARS = 'y' | YEARS = 'year' | YEARS = 'years'
;

MonitoringConditionDeclaration:
	'where' expression = ConditionalExpression
;

FactRule:
	'factrule' name = ID '{'
		(
			sources += EventSourceDeclaration |
			assignments += AttributeAssignment
		)*
	'}'
;

AttributeAssignment:
	'set' name=ID value=ConditionalExpression
;

/* Expression syntax adapted from 
 * http://openjdk.java.net/projects/compiler-grammar/antlrworks/Java.g
 * and the Xbase XExpression 	
 */
ConditionalExpression:
	ConditionalOrExpression
;

ConditionalOrExpression returns ConditionalExpression:
	ConditionalAndExpression (=>({BinaryExpression.leftOperand=current} 
		operator=OrOperator) rightOperand=ConditionalAndExpression
	)*
;

OrOperator:
	{OrOperator} ('||' | 'or' | 'OR')
;

ConditionalAndExpression returns ConditionalExpression:
	EqualityExpression (=>({BinaryExpression.leftOperand=current} 
		operator=AndOperator) rightOperand=EqualityExpression)*
;

AndOperator:
	{AndOperator} ('&&' | 'and' | 'AND')
;

EqualityExpression returns ConditionalExpression:
	RelationalExpression (=>({BinaryExpression.leftOperand=current}
		operator=EqualityOperator) rightOperand=RelationalExpression
	)*
;

EqualityOperator:
	{EqualityOperator} ('=' | '!=')
;

RelationalExpression returns ConditionalExpression:
	AdditiveExpression (=>({BinaryExpression.leftOperand=current}
		operator=CompareOperator) rightOperand=AdditiveExpression
	)*
;

CompareOperator:
	{CompareOperator} ('<' | '<=' | '>=' | '>')
;

AdditiveExpression returns ConditionalExpression:
	MultiplicativeExpression (=>({BinaryExpression.leftOperand=current}
		operator=AdditiveOperator) 
		rightOperand=MultiplicativeExpression
	)*
;

AdditiveOperator:
	{AdditiveOperator} ('+' | '-')
;

MultiplicativeExpression returns ConditionalExpression:
	UnaryExpression (=>({BinaryExpression.leftOperand=current}
		operator=MultiplicativeOperator)
		rightOperand=UnaryExpression
	)*
;

MultiplicativeOperator:
	{MultiplicativeOperator} ('*' | '/' | '%')
;

UnaryExpression returns ConditionalExpression:
	{UnaryExpression} operator=UnaryOperatorLiteral 
		operand=PrimaryExpression 
	| PrimaryExpression
;

UnaryOperatorLiteral:
	'-' | 'not' | '!'
;

UnaryOperator returns Operator:
	operator=UnaryOperatorLiteral
;

Operator returns Operator:
	AndOperator | OrOperator | CompareOperator | AdditiveOperator |
	MultiplicativeOperator
;

PrimaryExpression returns ConditionalExpression:
	ParenthesizedExpression |
	Literal |
	FeatureCall
;

ParenthesizedExpression returns ConditionalExpression:
	'(' ConditionalExpression ')'
;

FeatureCall:
	{FeatureCall} attribute=[EventAttribute | QualifiedName]
;

Literal returns ConditionalExpression:
	BooleanLiteral |
	NumberLiteral |
	NullLiteral |
	StringLiteral 
;

BooleanLiteral returns ConditionalExpression:
	{BooleanLiteral} ('false' | isTrue ?= 'true')
;

NumberLiteral returns ConditionalExpression:
	{NumberLiteral} value=Number	
;


NullLiteral returns ConditionalExpression:
	{NullLiteral} 'null'
;


StringLiteral returns ConditionalExpression:
	{StringLiteral} value=STRING
;

//QualifiedName:
//	ID ('.' ID)*
//;

QualifiedNameWithWildcard:
	QualifiedName '.*'?	
;

